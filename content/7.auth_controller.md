---
doc_meta:
    group: "Core Concepts"
    icon: "ph-bold ph-shield-check"
---
# Auth Controller Guide

Welcome to the Finch Auth Controller Guide! This guide will walk you through the steps to create and use an Auth Controller in your Finch application. Whether you're a seasoned developer or just starting, Finch offers a robust set of tools to simplify server-side web app development.

## What is an Auth Controller?

An Auth Controller in Finch is a class that handles authentication and authorization for your application. It is responsible for processing authentication requests, managing user sessions, and checking user permissions. Auth Controllers are used to secure your application and ensure that only authorized users can access certain resources.

## Creating an Auth Controller

The AuthController class is an abstract class that you need to extend to create your own Auth Controller. The AuthController class provides a set of methods that you can override to customize the authentication logic for your application. it extends the `Controller` class, so you can use all the features of the `Controller` class in your Auth Controller.

To create an Auth Controller, you need to extend the `AuthController` class. Here is an example of how to create a simple Auth Controller:  

**Note:** The `User` is a type of user model that you want to use in your application. You can use any type you want.

check this example in the Finch example project: [example/lib/controllers/auth_controller.dart](https://github.com/uproid/finch/blob/master/example/lib/controllers/auth_controller.dart)

```dart
class AppAuthController extends AuthController<User> {
    @override
  Future<bool> auth() async {
    return true;
  }

  @override
  Future<bool> authApi() async {
    return true;
  }

  @override
  Future<
      ({
        bool success,
        String message,
        User? user,
      })> checkLogin() async {
    return (
      success: true,
      message: 'Please login.',
      user: User(),
    );
  }

  @override
  Future<bool> checkPermission() async {
    return true;
  }

  @override
  Future<String> loginPost() async {
    return rq.renderString(text: "TEST", status: 403);
  }

  @override
  Future<String> logout() {
    return rq.renderString(text: "LOGOUT", status: 403);
  }

  @override
  void removeAuth() {
    // TODO: implement removeAuth
  }

  @override
  void updateAuth(String email, String password, User user) {
    // TODO: implement updateAuth
  }

  @override
  Future<String> newUser() {
    throw UnimplementedError();
  }

  @override
  Future<String> register() {
    throw UnimplementedError();
  }

  @override
  void removeAuth() {
    rq.session.remove('user');
    rq.removeCookie('user');
    userLogined = null;
  }

  @override
  void updateAuth(String email, String password, User user) {
    userLogined = user;
    rq.addSession('user', email);
  }
}
```
